
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Parsing arguments and building values &#8212; Python 2.7.16 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python 2.7.16 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="String conversion and formatting" href="conversion.html" />
    <link rel="prev" title="Data marshalling support" href="marshal.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/2/c-api/arg.html" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/switchers.js"></script>
 
    

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="conversion.html" title="String conversion and formatting"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="marshal.html" title="Data marshalling support"
             accesskey="P">previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">en</span>
          <span class="version_switcher_placeholder">2.7.16</span>
          <a href="../index.html">Documentation</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python/C API Reference Manual</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="utilities.html" accesskey="U">Utilities</a> &#187;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="parsing-arguments-and-building-values">
<span id="arg-parsing"></span><h1>Parsing arguments and building values<a class="headerlink" href="#parsing-arguments-and-building-values" title="Permalink to this headline">¶</a></h1>
<p>These functions are useful when creating your own extensions functions and
methods.  Additional information and examples are available in
<a class="reference internal" href="../extending/index.html#extending-index"><span class="std std-ref">Extending and Embedding the Python Interpreter</span></a>.</p>
<p>The first three of these functions described, <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>,
<a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>, and <a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_Parse()</span></code></a>, all use
<em>format strings</em> which are used to tell the function about the expected
arguments.  The format strings use the same syntax for each of these
functions.</p>
<p>A format string consists of zero or more “format units.”  A format unit
describes one Python object; it is usually a single character or a
parenthesized sequence of format units.  With a few exceptions, a format unit
that is not a parenthesized sequence normally corresponds to a single address
argument to these functions.  In the following description, the quoted form is
the format unit; the entry in (round) parentheses is the Python object type
that matches the format unit; and the entry in [square] brackets is the type
of the C variable(s) whose address should be passed.</p>
<p>These formats allow accessing an object as a contiguous chunk of memory.
You don’t have to provide raw storage for the returned unicode or bytes
area.  Also, you won’t have to release any memory yourself, except with the
<code class="docutils literal notranslate"><span class="pre">es</span></code>, <code class="docutils literal notranslate"><span class="pre">es#</span></code>, <code class="docutils literal notranslate"><span class="pre">et</span></code> and <code class="docutils literal notranslate"><span class="pre">et#</span></code> formats.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">s</span></code> (string or Unicode) [const char *]</dt><dd><p>Convert a Python string or Unicode object to a C pointer to a character
string.  You must not provide storage for the string itself; a pointer to
an existing string is stored into the character pointer variable whose
address you pass.  The C string is NUL-terminated.  The Python string must
not contain embedded NUL bytes; if it does, a <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception is
raised. Unicode objects are converted to C strings using the default
encoding.  If this conversion fails, a <a class="reference internal" href="../library/exceptions.html#exceptions.UnicodeError" title="exceptions.UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a> is raised.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s#</span></code> (string, Unicode or any read buffer compatible object) [const char *, int (or <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>, see below)]</dt><dd><p>This variant on <code class="docutils literal notranslate"><span class="pre">s</span></code> stores into two C variables, the first one a pointer
to a character string, the second one its length.  In this case the Python
string may contain embedded null bytes.  Unicode objects pass back a
pointer to the default encoded string version of the object if such a
conversion is possible.  All other read-buffer compatible objects pass back
a reference to the raw internal data representation.</p>
<p>Starting with Python 2.5 the type of the length argument can be controlled
by defining the macro <code class="xref c c-macro docutils literal notranslate"><span class="pre">PY_SSIZE_T_CLEAN</span></code> before including
<code class="file docutils literal notranslate"><span class="pre">Python.h</span></code>.  If the macro is defined, length is a <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>
rather than an int.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s*</span></code> (string, Unicode, or any buffer compatible object) [Py_buffer]</dt><dd><p>Similar to <code class="docutils literal notranslate"><span class="pre">s#</span></code>, this code fills a Py_buffer structure provided by the
caller.  The buffer gets locked, so that the caller can subsequently use
the buffer even inside a <code class="docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code> block; the caller is
responsible for calling <code class="docutils literal notranslate"><span class="pre">PyBuffer_Release</span></code> with the structure after it
has processed the data.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.6.</span></p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z</span></code> (string, Unicode  or <code class="docutils literal notranslate"><span class="pre">None</span></code>) [const char *]</dt><dd><p>Like <code class="docutils literal notranslate"><span class="pre">s</span></code>, but the Python object may also be <code class="docutils literal notranslate"><span class="pre">None</span></code>, in which case the C
pointer is set to <em>NULL</em>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z#</span></code> (string, Unicode, <code class="docutils literal notranslate"><span class="pre">None</span></code> or any read buffer compatible object) [const char *, int]</dt><dd><p>This is to <code class="docutils literal notranslate"><span class="pre">s#</span></code> as <code class="docutils literal notranslate"><span class="pre">z</span></code> is to <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z*</span></code> (string, Unicode, <code class="docutils literal notranslate"><span class="pre">None</span></code> or any buffer compatible object) [Py_buffer]</dt><dd><p>This is to <code class="docutils literal notranslate"><span class="pre">s*</span></code> as <code class="docutils literal notranslate"><span class="pre">z</span></code> is to <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.6.</span></p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u</span></code> (Unicode) [Py_UNICODE *]</dt><dd><p>Convert a Python Unicode object to a C pointer to a NUL-terminated buffer
of 16-bit Unicode (UTF-16) data.  As with <code class="docutils literal notranslate"><span class="pre">s</span></code>, there is no need to
provide storage for the Unicode data buffer; a pointer to the existing
Unicode data is stored into the <a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> pointer variable whose
address you pass.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u#</span></code> (Unicode) [Py_UNICODE *, int]</dt><dd><p>This variant on <code class="docutils literal notranslate"><span class="pre">u</span></code> stores into two C variables, the first one a pointer
to a Unicode data buffer, the second one its length. Non-Unicode objects
are handled by interpreting their read-buffer pointer as pointer to a
<a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></a> array.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">es</span></code> (string, Unicode or character buffer compatible object) [const char *encoding, char **buffer]</dt><dd><p>This variant on <code class="docutils literal notranslate"><span class="pre">s</span></code> is used for encoding Unicode and objects convertible
to Unicode into a character buffer. It only works for encoded data without
embedded NUL bytes.</p>
<p>This format requires two arguments.  The first is only used as input, and
must be a <code class="xref c c-type docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code> which points to the name of an encoding as
a NUL-terminated string, or <em>NULL</em>, in which case the default encoding is
used.  An exception is raised if the named encoding is not known to Python.
The second argument must be a <code class="xref c c-type docutils literal notranslate"><span class="pre">char**</span></code>; the value of the pointer
it references will be set to a buffer with the contents of the argument
text.  The text will be encoded in the encoding specified by the first
argument.</p>
<p><a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> will allocate a buffer of the needed size, copy
the encoded data into this buffer and adjust <em>*buffer</em> to reference the
newly allocated storage.  The caller is responsible for calling
<a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a> to free the allocated buffer after use.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">et</span></code> (string, Unicode or character buffer compatible object) [const char *encoding, char **buffer]</dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">es</span></code> except that 8-bit string objects are passed through without
recoding them.  Instead, the implementation assumes that the string object
uses the encoding passed in as parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">es#</span></code> (string, Unicode or character buffer compatible object) [const char *encoding, char **buffer, int *buffer_length]</dt><dd><p>This variant on <code class="docutils literal notranslate"><span class="pre">s#</span></code> is used for encoding Unicode and objects convertible
to Unicode into a character buffer.  Unlike the <code class="docutils literal notranslate"><span class="pre">es</span></code> format, this variant
allows input data which contains NUL characters.</p>
<p>It requires three arguments.  The first is only used as input, and must be
a <code class="xref c c-type docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code> which points to the name of an encoding as a
NUL-terminated string, or <em>NULL</em>, in which case the default encoding is
used.  An exception is raised if the named encoding is not known to Python.
The second argument must be a <code class="xref c c-type docutils literal notranslate"><span class="pre">char**</span></code>; the value of the pointer
it references will be set to a buffer with the contents of the argument
text.  The text will be encoded in the encoding specified by the first
argument.  The third argument must be a pointer to an integer; the
referenced integer will be set to the number of bytes in the output buffer.</p>
<p>There are two modes of operation:</p>
<p>If <em>*buffer</em> points a <em>NULL</em> pointer, the function will allocate a buffer
of the needed size, copy the encoded data into this buffer and set
<em>*buffer</em> to reference the newly allocated storage.  The caller is
responsible for calling <a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a> to free the allocated buffer
after usage.</p>
<p>If <em>*buffer</em> points to a non-<em>NULL</em> pointer (an already allocated buffer),
<a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> will use this location as the buffer and
interpret the initial value of <em>*buffer_length</em> as the buffer size.  It
will then copy the encoded data into the buffer and NUL-terminate it.  If
the buffer is not large enough, a <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> will be set.
Note: starting from Python 3.6 a <a class="reference internal" href="../library/exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> will be set.</p>
<p>In both cases, <em>*buffer_length</em> is set to the length of the encoded data
without the trailing NUL byte.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">et#</span></code> (string, Unicode or character buffer compatible object) [const char *encoding, char **buffer, int *buffer_length]</dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">es#</span></code> except that string objects are passed through without
recoding them. Instead, the implementation assumes that the string object
uses the encoding passed in as parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code> (integer) [unsigned char]</dt><dd><p>Convert a nonnegative Python integer to an unsigned tiny int, stored in a C
<code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">B</span></code> (integer) [unsigned char]</dt><dd><p>Convert a Python integer to a tiny int without overflow checking, stored in
a C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.3.</span></p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h</span></code> (integer) [short int]</dt><dd><p>Convert a Python integer to a C <code class="xref c c-type docutils literal notranslate"><span class="pre">short</span> <span class="pre">int</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">H</span></code> (integer) [unsigned short int]</dt><dd><p>Convert a Python integer to a C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">int</span></code>, without
overflow checking.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.3.</span></p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i</span></code> (integer) [int]</dt><dd><p>Convert a Python integer to a plain C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I</span></code> (integer) [unsigned int]</dt><dd><p>Convert a Python integer to a C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>, without overflow
checking.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.3.</span></p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">l</span></code> (integer) [long int]</dt><dd><p>Convert a Python integer to a C <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">int</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">k</span></code> (integer) [unsigned long]</dt><dd><p>Convert a Python integer or long integer to a C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>
without overflow checking.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.3.</span></p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">L</span></code> (integer) [PY_LONG_LONG]</dt><dd><p>Convert a Python integer to a C <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code>.  This format is only
available on platforms that support <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code> (or <code class="xref c c-type docutils literal notranslate"><span class="pre">_int64</span></code>
on Windows).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">K</span></code> (integer) [unsigned PY_LONG_LONG]</dt><dd><p>Convert a Python integer or long integer to a C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code>
without overflow checking.  This format is only available on platforms that
support <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> (or <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">_int64</span></code> on
Windows).</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.3.</span></p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code> (integer) [Py_ssize_t]</dt><dd><p>Convert a Python integer or long integer to a C <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.5.</span></p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code> (string of length 1) [char]</dt><dd><p>Convert a Python character, represented as a string of length 1, to a C
<code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f</span></code> (float) [float]</dt><dd><p>Convert a Python floating point number to a C <code class="xref c c-type docutils literal notranslate"><span class="pre">float</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d</span></code> (float) [double]</dt><dd><p>Convert a Python floating point number to a C <code class="xref c c-type docutils literal notranslate"><span class="pre">double</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">D</span></code> (complex) [Py_complex]</dt><dd><p>Convert a Python complex number to a C <a class="reference internal" href="complex.html#c.Py_complex" title="Py_complex"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_complex</span></code></a> structure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">O</span></code> (object) [PyObject *]</dt><dd><p>Store a Python object (without any conversion) in a C object pointer.  The
C program thus receives the actual object that was passed.  The object’s
reference count is not increased.  The pointer stored is not <em>NULL</em>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">O!</span></code> (object) [<em>typeobject</em>, PyObject *]</dt><dd><p>Store a Python object in a C object pointer.  This is similar to <code class="docutils literal notranslate"><span class="pre">O</span></code>, but
takes two C arguments: the first is the address of a Python type object,
the second is the address of the C variable (of type <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject*</span></code></a>)
into which the object pointer is stored.  If the Python object does not
have the required type, <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> is raised.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">O&amp;</span></code> (object) [<em>converter</em>, <em>anything</em>]</dt><dd><p>Convert a Python object to a C variable through a <em>converter</em> function.
This takes two arguments: the first is a function, the second is the
address of a C variable (of arbitrary type), converted to <code class="xref c c-type docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code>.
The <em>converter</em> function in turn is called as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">status</span> <span class="o">=</span> <span class="n">converter</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
</pre></div>
</div>
<p>where <em>object</em> is the Python object to be converted and <em>address</em> is the
<code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code> argument that was passed to the <a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_Parse*()</span></code></a>
function.  The returned <em>status</em> should be <code class="docutils literal notranslate"><span class="pre">1</span></code> for a successful
conversion and <code class="docutils literal notranslate"><span class="pre">0</span></code> if the conversion has failed.  When the conversion
fails, the <em>converter</em> function should raise an exception and leave the
content of <em>address</em> unmodified.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S</span></code> (string) [PyStringObject *]</dt><dd><p>Like <code class="docutils literal notranslate"><span class="pre">O</span></code> but requires that the Python object is a string object.  Raises
<a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> if the object is not a string object.  The C variable may
also be declared as <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject*</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">U</span></code> (Unicode string) [PyUnicodeObject *]</dt><dd><p>Like <code class="docutils literal notranslate"><span class="pre">O</span></code> but requires that the Python object is a Unicode object.  Raises
<a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> if the object is not a Unicode object.  The C variable may
also be declared as <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject*</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">t#</span></code> (read-only character buffer) [char *, int]</dt><dd><p>Like <code class="docutils literal notranslate"><span class="pre">s#</span></code>, but accepts any object which implements the read-only buffer
interface.  The <code class="xref c c-type docutils literal notranslate"><span class="pre">char*</span></code> variable is set to point to the first byte
of the buffer, and the <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> is set to the length of the buffer.
Only single-segment buffer objects are accepted; <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> is raised
for all others.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">w</span></code> (read-write character buffer) [char *]</dt><dd><p>Similar to <code class="docutils literal notranslate"><span class="pre">s</span></code>, but accepts any object which implements the read-write
buffer interface.  The caller must determine the length of the buffer by
other means, or use <code class="docutils literal notranslate"><span class="pre">w#</span></code> instead.  Only single-segment buffer objects are
accepted; <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> is raised for all others.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">w#</span></code> (read-write character buffer) [char *, Py_ssize_t]</dt><dd><p>Like <code class="docutils literal notranslate"><span class="pre">s#</span></code>, but accepts any object which implements the read-write buffer
interface.  The <code class="xref c c-type docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> variable is set to point to the first byte
of the buffer, and the <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code> is set to the length of the
buffer.  Only single-segment buffer objects are accepted; <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>
is raised for all others.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">w*</span></code> (read-write byte-oriented buffer) [Py_buffer]</dt><dd><p>This is to <code class="docutils literal notranslate"><span class="pre">w</span></code> what <code class="docutils literal notranslate"><span class="pre">s*</span></code> is to <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.6.</span></p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(items)</span></code> (tuple) [<em>matching-items</em>]</dt><dd><p>The object must be a Python sequence whose length is the number of format
units in <em>items</em>.  The C arguments must correspond to the individual format
units in <em>items</em>.  Format units for sequences may be nested.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Prior to Python version 1.5.2, this format specifier only accepted a
tuple containing the individual parameters, not an arbitrary sequence.
Code which previously caused <a class="reference internal" href="../library/exceptions.html#exceptions.TypeError" title="exceptions.TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> to be raised here may now
proceed without an exception.  This is not expected to be a problem for
existing code.</p>
</div>
</dd>
</dl>
<p>It is possible to pass Python long integers where integers are requested;
however no proper range checking is done — the most significant bits are
silently truncated when the receiving field is too small to receive the value
(actually, the semantics are inherited from downcasts in C — your mileage
may vary).</p>
<p>A few other characters have a meaning in a format string.  These may not occur
inside nested parentheses.  They are:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">|</span></code></dt><dd><p>Indicates that the remaining arguments in the Python argument list are
optional.  The C variables corresponding to optional arguments should be
initialized to their default value — when an optional argument is not
specified, <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> does not touch the contents of the
corresponding C variable(s).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">:</span></code></dt><dd><p>The list of format units ends here; the string after the colon is used as
the function name in error messages (the “associated value” of the
exception that <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> raises).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">;</span></code></dt><dd><p>The list of format units ends here; the string after the semicolon is used
as the error message <em>instead</em> of the default error message.  <code class="docutils literal notranslate"><span class="pre">:</span></code> and
<code class="docutils literal notranslate"><span class="pre">;</span></code> mutually exclude each other.</p>
</dd>
</dl>
<p>Note that any Python object references which are provided to the caller are
<em>borrowed</em> references; do not decrement their reference count!</p>
<p>Additional arguments passed to these functions must be addresses of variables
whose type is determined by the format string; these are used to store values
from the input tuple.  There are a few cases, as described in the list of
format units above, where these parameters are used as input values; they
should match what is specified for the corresponding format unit in that case.</p>
<p>For the conversion to succeed, the <em>arg</em> object must match the format and the
format must be exhausted.  On success, the <a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_Parse*()</span></code></a> functions
return true, otherwise they return false and raise an appropriate exception.
When the <a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_Parse*()</span></code></a> functions fail due to conversion failure in
one of the format units, the variables at the addresses corresponding to that
and the following format units are left untouched.</p>
<dl class="function">
<dt id="c.PyArg_ParseTuple">
int <code class="descname">PyArg_ParseTuple</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *args</em>, const char<em> *format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_ParseTuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the parameters of a function that takes only positional parameters
into local variables.  Returns true on success; on failure, it returns
false and raises the appropriate exception.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_VaParse">
int <code class="descname">PyArg_VaParse</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *args</em>, const char<em> *format</em>, va_list<em> vargs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_VaParse" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>, except that it accepts a va_list
rather than a variable number of arguments.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_ParseTupleAndKeywords">
int <code class="descname">PyArg_ParseTupleAndKeywords</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *args</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *kw</em>, const char<em> *format</em>, char<em> *keywords[]</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_ParseTupleAndKeywords" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the parameters of a function that takes both positional and keyword
parameters into local variables.  Returns true on success; on failure, it
returns false and raises the appropriate exception.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_VaParseTupleAndKeywords">
int <code class="descname">PyArg_VaParseTupleAndKeywords</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *args</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *kw</em>, const char<em> *format</em>, char<em> *keywords[]</em>, va_list<em> vargs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_VaParseTupleAndKeywords" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to <a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>, except that it accepts a
va_list rather than a variable number of arguments.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_Parse">
int <code class="descname">PyArg_Parse</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *args</em>, const char<em> *format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_Parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Function used to deconstruct the argument lists of “old-style” functions
— these are functions which use the <a class="reference internal" href="structures.html#METH_OLDARGS" title="METH_OLDARGS"><code class="xref py py-const docutils literal notranslate"><span class="pre">METH_OLDARGS</span></code></a> parameter
parsing method.  This is not recommended for use in parameter parsing in
new code, and most code in the standard interpreter has been modified to no
longer use this for that purpose.  It does remain a convenient way to
decompose other tuples, however, and may continue to be used for that
purpose.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_UnpackTuple">
int <code class="descname">PyArg_UnpackTuple</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em> *args</em>, const char<em> *name</em>, Py_ssize_t<em> min</em>, Py_ssize_t<em> max</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.PyArg_UnpackTuple" title="Permalink to this definition">¶</a></dt>
<dd><p>A simpler form of parameter retrieval which does not use a format string to
specify the types of the arguments.  Functions which use this method to
retrieve their parameters should be declared as <a class="reference internal" href="structures.html#METH_VARARGS" title="METH_VARARGS"><code class="xref py py-const docutils literal notranslate"><span class="pre">METH_VARARGS</span></code></a> in
function or method tables.  The tuple containing the actual parameters
should be passed as <em>args</em>; it must actually be a tuple.  The length of the
tuple must be at least <em>min</em> and no more than <em>max</em>; <em>min</em> and <em>max</em> may be
equal.  Additional arguments must be passed to the function, each of which
should be a pointer to a <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject*</span></code></a> variable; these will be filled
in with the values from <em>args</em>; they will contain borrowed references.  The
variables which correspond to optional parameters not given by <em>args</em> will
not be filled in; these should be initialized by the caller. This function
returns true on success and false if <em>args</em> is not a tuple or contains the
wrong number of elements; an exception will be set if there was a failure.</p>
<p>This is an example of the use of this function, taken from the sources for
the <code class="xref py py-mod docutils literal notranslate"><span class="pre">_weakref</span></code> helper module for weak references:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">weakref_ref</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">PyArg_UnpackTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;ref&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">PyWeakref_NewRef</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">callback</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The call to <a class="reference internal" href="#c.PyArg_UnpackTuple" title="PyArg_UnpackTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_UnpackTuple()</span></code></a> in this example is entirely
equivalent to this call to <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;O|O:ref&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 2.5: </span>This function used an <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> type for <em>min</em> and <em>max</em>. This might
require changes in your code for properly supporting 64-bit systems.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.Py_BuildValue">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">Py_BuildValue</code><span class="sig-paren">(</span>const char<em> *format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.Py_BuildValue" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a new value based on a format string similar to those accepted by
the <a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_Parse*()</span></code></a> family of functions and a sequence of values.
Returns the value or <em>NULL</em> in the case of an error; an exception will be
raised if <em>NULL</em> is returned.</p>
<p><a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a> does not always build a tuple.  It builds a tuple
only if its format string contains two or more format units.  If the format
string is empty, it returns <code class="docutils literal notranslate"><span class="pre">None</span></code>; if it contains exactly one format
unit, it returns whatever object is described by that format unit.  To
force it to return a tuple of size <code class="docutils literal notranslate"><span class="pre">0</span></code> or one, parenthesize the format
string.</p>
<p>When memory buffers are passed as parameters to supply data to build
objects, as for the <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">s#</span></code> formats, the required data is copied.
Buffers provided by the caller are never referenced by the objects created
by <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a>.  In other words, if your code invokes
<code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> and passes the allocated memory to <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a>,
your code is responsible for calling <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> for that memory once
<a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a> returns.</p>
<p>In the following description, the quoted form is the format unit; the entry
in (round) parentheses is the Python object type that the format unit will
return; and the entry in [square] brackets is the type of the C value(s) to
be passed.</p>
<p>The characters space, tab, colon and comma are ignored in format strings
(but not within format units such as <code class="docutils literal notranslate"><span class="pre">s#</span></code>).  This can be used to make
long format strings a tad more readable.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">s</span></code> (string) [char *]</dt><dd><p>Convert a null-terminated C string to a Python object.  If the C string
pointer is <em>NULL</em>, <code class="docutils literal notranslate"><span class="pre">None</span></code> is used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">s#</span></code> (string) [char *, int]</dt><dd><p>Convert a C string and its length to a Python object.  If the C string
pointer is <em>NULL</em>, the length is ignored and <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z</span></code> (string or <code class="docutils literal notranslate"><span class="pre">None</span></code>) [char *]</dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">z#</span></code> (string or <code class="docutils literal notranslate"><span class="pre">None</span></code>) [char *, int]</dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">s#</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u</span></code> (Unicode string) [Py_UNICODE *]</dt><dd><p>Convert a null-terminated buffer of Unicode (UCS-2 or UCS-4) data to a
Python Unicode object.  If the Unicode buffer pointer is <em>NULL</em>,
<code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u#</span></code> (Unicode string) [Py_UNICODE *, int]</dt><dd><p>Convert a Unicode (UCS-2 or UCS-4) data buffer and its length to a
Python Unicode object.   If the Unicode buffer pointer is <em>NULL</em>, the
length is ignored and <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">i</span></code> (integer) [int]</dt><dd><p>Convert a plain C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> to a Python integer object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">b</span></code> (integer) [char]</dt><dd><p>Convert a plain C <code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code> to a Python integer object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">h</span></code> (integer) [short int]</dt><dd><p>Convert a plain C <code class="xref c c-type docutils literal notranslate"><span class="pre">short</span> <span class="pre">int</span></code> to a Python integer object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">l</span></code> (integer) [long int]</dt><dd><p>Convert a C <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">int</span></code> to a Python integer object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">B</span></code> (integer) [unsigned char]</dt><dd><p>Convert a C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code> to a Python integer object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">H</span></code> (integer) [unsigned short int]</dt><dd><p>Convert a C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">int</span></code> to a Python integer object.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">I</span></code> (integer/long) [unsigned int]</dt><dd><p>Convert a C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> to a Python integer object or a Python
long integer object, if it is larger than <code class="docutils literal notranslate"><span class="pre">sys.maxint</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">k</span></code> (integer/long) [unsigned long]</dt><dd><p>Convert a C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code> to a Python integer object or a
Python long integer object, if it is larger than <code class="docutils literal notranslate"><span class="pre">sys.maxint</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">L</span></code> (long) [PY_LONG_LONG]</dt><dd><p>Convert a C <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code> to a Python long integer object. Only
available on platforms that support <code class="xref c c-type docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">K</span></code> (long) [unsigned PY_LONG_LONG]</dt><dd><p>Convert a C <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> to a Python long integer object.
Only available on platforms that support <code class="xref c c-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code> (int) [Py_ssize_t]</dt><dd><p>Convert a C <code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code> to a Python integer or long integer.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.5.</span></p>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c</span></code> (string of length 1) [char]</dt><dd><p>Convert a C <code class="xref c c-type docutils literal notranslate"><span class="pre">int</span></code> representing a character to a Python string of
length 1.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">d</span></code> (float) [double]</dt><dd><p>Convert a C <code class="xref c c-type docutils literal notranslate"><span class="pre">double</span></code> to a Python floating point number.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f</span></code> (float) [float]</dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">d</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">D</span></code> (complex) [Py_complex *]</dt><dd><p>Convert a C <a class="reference internal" href="complex.html#c.Py_complex" title="Py_complex"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_complex</span></code></a> structure to a Python complex number.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">O</span></code> (object) [PyObject *]</dt><dd><p>Pass a Python object untouched (except for its reference count, which is
incremented by one).  If the object passed in is a <em>NULL</em> pointer, it is
assumed that this was caused because the call producing the argument
found an error and set an exception. Therefore, <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a>
will return <em>NULL</em> but won’t raise an exception.  If no exception has
been raised yet, <a class="reference internal" href="../library/exceptions.html#exceptions.SystemError" title="exceptions.SystemError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemError</span></code></a> is set.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">S</span></code> (object) [PyObject *]</dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">O</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">N</span></code> (object) [PyObject *]</dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">O</span></code>, except it doesn’t increment the reference count on the
object.  Useful when the object is created by a call to an object
constructor in the argument list.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">O&amp;</span></code> (object) [<em>converter</em>, <em>anything</em>]</dt><dd><p>Convert <em>anything</em> to a Python object through a <em>converter</em> function.
The function is called with <em>anything</em> (which should be compatible with
<code class="xref c c-type docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code>) as its argument and should return a “new” Python
object, or <em>NULL</em> if an error occurred.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(items)</span></code> (tuple) [<em>matching-items</em>]</dt><dd><p>Convert a sequence of C values to a Python tuple with the same number of
items.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[items]</span></code> (list) [<em>matching-items</em>]</dt><dd><p>Convert a sequence of C values to a Python list with the same number of
items.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{items}</span></code> (dictionary) [<em>matching-items</em>]</dt><dd><p>Convert a sequence of C values to a Python dictionary.  Each pair of
consecutive C values adds one item to the dictionary, serving as key and
value, respectively.</p>
</dd>
</dl>
<p>If there is an error in the format string, the <a class="reference internal" href="../library/exceptions.html#exceptions.SystemError" title="exceptions.SystemError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemError</span></code></a> exception
is set and <em>NULL</em> returned.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_VaBuildValue">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <code class="descname">Py_VaBuildValue</code><span class="sig-paren">(</span>const char<em> *format</em>, va_list<em> vargs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_VaBuildValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a>, except that it accepts a va_list
rather than a variable number of arguments.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="marshal.html"
                        title="previous chapter">Data marshalling support</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="conversion.html"
                        title="next chapter">String conversion and formatting</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/c-api/arg.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="conversion.html" title="String conversion and formatting"
             >next</a> |</li>
        <li class="right" >
          <a href="marshal.html" title="Data marshalling support"
             >previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <span class="language_switcher_placeholder">en</span>
          <span class="version_switcher_placeholder">2.7.16</span>
          <a href="../index.html">Documentation</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python/C API Reference Manual</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="utilities.html" >Utilities</a> &#187;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2019, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="https://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Jun 04, 2019.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 2.0.1.
    </div>

  </body>
</html>