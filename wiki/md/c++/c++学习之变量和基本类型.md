---
title: c++学习之变量和基本类型
date: 2020-10-16 10:05:00
categories: c++
index_img: /img/articles/c++.jpg
tags:
	- c++
---

本文对《Primer C++》中的变量和基本类型的零碎知识点进行记录与梳理。

<!-- more -->

# 变量与基本类型

## 基本内置类型

- 算术类型包括整型与浮点型。算术类型所占的比特位数，在不同的机器上是有所区别的，C++标准只是规定了各个算术类型的最小尺寸，允许不同硬件平台的编译器赋予这些算术类型更大的尺寸。
- 字符型被分为char、signed char、unsigned char三种类型。其中char与signed char类型是不相同的，类型char具体为有符号类型还是无符号类型，取决于该硬件平台的编译器。
- 在算术表达式中，不要使用char与bool类型。因为char类型在一些机器上是有符号的，但是在另一些机器上却是无符号的，使用char进行算术运算容易出错。
- 执行浮点运算，选用double。float精度通常不够，并且double与float的计算代价相差不大。
- 当给有符号类型的变量赋予一个超出其类型表示范围的值时，其结果是未定义的，程序可能崩溃。
- 不要在表达式中混用有符号类型与无符号类型。当有符号类型取值为负数时，表达式计算结果可能会异常。
- 默认情况下，十进制整型字面值，或者十进制浮点型字面值是有符号的数，而八进制与十六进制的整型或者浮点型字面值可能是有符号的，也可能是无符号的。

## 变量

- 在c++语言中，初始化与赋值是两个完全不同的操作，初始化不是赋值。初始化的含义是在创建变量时赋予一个初始值，而赋值的含义是将对象的当前值擦除，而以一个新的值来替代。
- 当使用列表初始化的方式，初始化内置类型的变量时，若初始值存在丢失信息的风险，则编译器将报错误，比如：

~~~c++
long double ld = 3.14159265358;
int a{ld};		//error: 存在丢失信息风险，编译器报错
int b = {ld};	//error: 存在丢失信息风险，编译器报错
int c(ld);		//ok: 可成功初始化，但是丢失精度
int d = ld;		//ok: 可成功初始化，但是丢失精度
~~~

- 定义于函数体内的内置类型的变量，如果没有被初始化，则其不会被默认初始化，其值是未定义的。定义于函数体外的内置类型的变量，将会被默认初始化为0。
- 强烈建议初始化每一个内置类型的变量。
- 建议在对象第一次被使用的地方附近定义对象，这样更容易找到对象的定义，也更容易赋予一个合理的初始值。

## 复合类型

- 引用必须被初始化，无法令引用重新绑定到另一个对象。
- 引用并非对象，引用即别名，只是为一个已经存在的对象所起的另一个名字。
- 不能定义引用的引用，因为引用本身不是对象。
- 不能定义指向引用的指针，因为引用不是对象，没有实际的地址。
- c++11标准引入指针字面值nullptr作为空指针的值。旧的程序会使用在头文件cstdlib中定义的预处理变量NULL作为空指针的值。现在的c++程序尽量使用nullptr，避免使用NULL。
- 注意以下的变量声明的写法习惯：

~~~c++
int* p;			//虽然合法，但是容易引起误导，不推荐
int* p1, p2;	//p1为指针，p2为int型变量，容易引起误导，不推荐
int *p1, p2;	//p1为指针，p2为int型变量，推荐
~~~

- 引用不是对象，因此不能定义指向引用的指针。但是指针是对象，所以存在指针的引用。比如：

~~~c++
int *p;
int *&r = p;
//r是一个对指针p的引用
//解读原则：从右向左阅读r的定义，离变量名最近的符号对变量的类型有最直接的影响
//离变量名r最近的符号为&，因此r为引用
//声明符的其余部分int *用于确定r引用的类型
//因此r为引用，引用的对象类型为指向int型的指针（int *）
~~~

## const限定符

- 默认情况下，const对象被设定为仅在本文件中有效，当多个文件中出现同名的const变量时，等同于在不同的文件中分别定义了互相独立的多个变量。如果想在多个文件之间共享const对象，必须在对象的定义之前添加extern关键字。
- 所谓指向常量的指针，或者指向常量的引用，都是指针或者引用的“自以为是”。实际上，指针或者引用并不知道其指向的对象是常量，还是非常量。只不过指向常量的指针与引用，遵循不通过自己去改变所指的对象这一原则。实际上对象可能为非常量的，也有其他的途径去修改对象的值。

## 处理类型

- 有两只方式来定义**类型别名**，一种是使用关键字typedef，另一种是c++11新标准规定的using别名声明，比如：

~~~c++
typedef char *pstring;	//pstring是char *的别名
using SI = Sales_item;	//SI是Sales_item是别名
~~~

- 如果某个类型别名指代的是复合类型或者常量，将其用到声明语句中将会产生意想不到的后果！比如：

~~~c++
typedef char *pstring;
const pstring cstr;		//cstr是指向char的常量指针
const char *cstr;		//error: 是对const pstring cstr的错误理解
//const是对pstring的修饰
//pstring是指向char的指针
//因此，const pstring是指向char的常量指针，而不是指向常量字符的指针
//将类型别名替换为本来的样子，这样的理解是错误的！！！
~~~

- 有种需求：希望从表达式的类型推断出要定义的变量的类型，但是不想使用该表达式的值初始化变量。c++11标准引入了类型指示符decltype，其作用是选择并返回操作数的数据类型。比如：

~~~c++
decltype(func()) sum = x;
//sum的数据类型，就是函数func的返回值类型
//编译器并不实际调用函数func，只是使用函数func的返回值的类型
~~~

- 如果decltype使用的是一个不加括号的变量，则得到的结果是这个变量的类型。如果decltype使用的是加上一层或者多层括号的变量，则编译器会将其当作一个表达式，这样decltype得到的是引用类型，比如：

~~~c++
int i = 0;
decltype(i) a;		//ok: a是一个未初始化的int类型
decltype((i)) b;	//error: b是引用类型int &，因此b必须初始化
//decltype((variable))的结果永远是引用
//decltype(variable)结果只有当variable本身就是一个引用时，才是引用
~~~